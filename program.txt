###### This program is designed to:
### 1. Prompt the User to enter 20 values
### 2. Prompt the user to enter another value
### 3. Return the value amongst the 20 values that is closest to the entered value.
###### Central program.
# 1) LDX for getting to First message
0008  A44B
# 2) JMA to first message printer at EA IX plus addr
0009  3440
# Make some IXR shortcuts for faster reference later Reserved 0A-2F
000A  0100
000B  0200
000C  0300
000D  0400
000E  0500
0010  0600
0011  0700
0012  0230
0013  0000
0014  0000
# Pointer address used in input loops at 0100
0015  0040
0016  00A4
## Shortcut to incrementing digit location - Jae
001D  0600
001E  0800
001F  0900
# Start of 1 int at addr 0040: # uncomment to debug.
0040  0031
0041  0032
0042  0033
0043  0034
0044  0035
# Start of 2 int:
0045  0000
# Start of 3 int:
004A  0000
# Start of 4 int:
004F  0000
# Start of 5 int:
0054  0000
# Start of 6 int:
0059  0000
# Start of 7 int:
005E  0000
# Start of 8 int:
0063  0000
# Start of 9 int:
0068  0000
# Start of 10 int:
006D  0000
# Start of 11 int:
0072  0000
# Start of 12 int:
0077  0000
# Start of 13 int:
007C  0000
# Start of 14 int:
0081  0000
# Start of 15 int:
0086  0000
# Start of 16 int:
008B  0000
# Start of 17 int:
0090  0000
# Start of 18 int:
0095  0000
# Start of 19 int:
009A  0000
# Start of 20 int:
009F  0000
# Start of USER INT
00A4  0000
##### Storage locations for Jae's part of the program.
## Store "difference" (initially 0)
00B0  0000
## Store "bestDifference" (initially 0)
00B5  0000
## Store "digitPosition" (initially 0)
00BA  0030
## Store "bestDigitPosition" (initially B)
00BB  0042
## Store "bestIntegerPointer" (initially 0)
00BC  0000
## Store "currentIntegerPointer" (initially 0)
00BD  0000
## Store "intListNumber" (initially 1)
00BE  0031
### NOTE, all other 000 and 001 addresses are reserved for Index Registers!
############################################
##### 100 Value storage loop - By Michael Ashery
#100-107 are reserved for storing variables.
#COUNTER - Counts number of integers
0100  0000
#DIGIT - Identify which digit of the int is being entered <<SET TO ZERO BEFORE TESTING FINAL
0101  0000
###The Check KB status loop. 
# Ensure Reg 1 empty #
0108  0403
# Check Device status. If on, set gpr0 to 1 #
0109  FC00
# If gpr0 is 0, jump back to 109. Otherwise proceed. #
010A  2849
##### Input Int Loop.
# LDX Pointer to X2 #
010B  A48F
# Input single char from buffer #
010C  F400
# Store char at pointer addr using IXR2 #
010D  0880
# Print char to printer #
010E  F801
# Increment DIGIT variable in gpr1 LDR,AIR,STR #
010F  0541
0110  1901
0111  0941
# Increment Pointer variable in gpr2 LDR,AIR,STR #
0112  0615
0113  1A01
0114  0A15
### Jump to next part if DIGIT==5. LDR DIGIT, LDR 0003,AIR 5,TRR,AIX x1 26,JCC
# LDR int r1 add101 (EA + 1) #
0115  0541
# LDR into r3 add0003 (3) CLEAR REG #
0116  0703
# AIR to r3 val 5  #
0117  1B05
#TRR r1 and r3 #
0118  59C0
#AIX x1 val 27 (1B in hex) #
0119  B85D
#JCC to 011D #
011A  3040
### Otherwise jump back to start of the Input Int Loop
#LDX with x100 from addr 000A #
011B  A44A
# JMA to 010B #
011C  344B
########## Integer Number controls.
# Scroll Printer #
011D  F000
# Set IXR1 to 100 #
011E  A44A
# Clear r3 #
011F  0703
# Store r3 at Digit to make it 0 (store 013C) #
0120  0B41
### Compare Pointer to 00A8, jump to comparison alg if true. LDR 0016 to r3,AIR 4,TRR,LDX 000E,JCC,LDX 000A
# LDR 0016 to r3  #
0121  0716
# AIR 4 to r3 #
0122  1B04
# TRR r2 to r3 #
0123  5AC0
# LDX 000E # (LDX to 500)
0124  A44E
# JCC to Jae's part (0500)
0125  3040
# LDX 000A
0126  A44A
###Compare COUNTER to immed 19. Jump to 230 if true. Cntr LDR r1, LDR r3 0, AIR r3, TRR r1r3, LDX r1, JCC
# LDR r1 addr0 #
0127  0540
# LDR r3 0 #
0128  0703
# AIR 19 to r3 #
0129  1B13
# TRR r1r3 #
012A  59C0
# LDX x1 addr 0012 #
012B  A452
# JCC #
012C  3040
### Increment COUNTER. AIR, LDX 000A, STR
#AIR r1 1 #
012D  1901
# LDX x1 val 0100 #
012E  A44A
# STR at addr 100 #
012F  0940
# Set Digit 0 LDA0003, JMA to 0108 #
#0130  0703
#0131  0841
0130  A44A
0131  3448
# Print out end result //TODO
#
############################################
###### 200 Print out first message - By Michael Ashery
# Clear IXR1 3)
0200  A443
# Load IXR1 with contents of 000D 3)
0201  A44D
#LDR char to reg (1/19)
0202  0440
#OUT char
0203  F801
#LDR char to reg (2/19)
0204  0441
#OUT char
0205  F801
#LDR char to reg (3/19)
0206  0442
#OUT char
0207  F801
#LDR char to reg (4/19)
0208  0443
#OUT char
0209  F801
#LDR char to reg (5/19)
020A  0444
#OUT char
020B  F801
#LDR char to reg (6/19)
020C  0445
#OUT char
020D  F801
#LDR char to reg (7/19)
020E  0446
#OUT char
020F  F801
#LDR char to reg (8/19)
0210  0447
#OUT char
0211  F801
#LDR char to reg (9/19)
0212  0448
#OUT char
0213  F801
#LDR char to reg (10/19)
0214  0449
#OUT char
0215  F801
#LDR char to reg (11/19)
0216  044A
#OUT char
0217  F801
#LDR char to reg (12/19)
0218  044B
#OUT char
0219  F801
#LDR char to reg (13/19)
021A  044C
#OUT char
021B  F801
#LDR char to reg (14/19)
021C  044D
#OUT char
021D  F801
#LDR char to reg (15/19)
021E  044E
#OUT char
021F  F801
#LDR char to reg (16/19)
0220  044F
#OUT char
0221  F801
#LDR char to reg (17/17)
0222  0450
#OUT char
0223  F801
# SCRL
0224  F000
# Clear IXR1 3)
0225  A443
# LDX 100 to IXR1
0226  A44A
#At the very end, jump back to the value storage loop at 108.
0227  3448
##########################################################
### Print out second message
# Clear IXR1 3)
0230  0403
# Load IXR1 with contents of 000D 3)
0231  A44D
# Add 17 to IXR1
0232  B851
#LDR char to reg (1/17)
0233  0440
#OUT char
0234  F801
#LDR char to reg (2/17)
0235  0441
#OUT char
0236  F801
#LDR char to reg (3/17)
0237  0442
#OUT char
0238  F801
#LDR char to reg (4/17)
0239  0443
#OUT char
023A  F801
#LDR char to reg (5/17)
023B  0444
#OUT char
023C  F801
#LDR char to reg (6/17)
023D  0445
#OUT char
023E  F801
#LDR char to reg (7/17)
023F  0446
#OUT char
0240  F801
#LDR char to reg (8/17)
0241  0447
#OUT char
0242  F801
#LDR char to reg (9/17)
0243  0448
#OUT char
0244  F801
#LDR char to reg (10/17)
0245  0449
#OUT char
0246  F801
#LDR char to reg (11/17)
0247  044A
#OUT char
0248  F801
#LDR char to reg (12/17)
0249  044B
#OUT char
024A  F801
#LDR char to reg (13/17)
024B  044C
#OUT char
024C  F801
#LDR char to reg (14/17)
024D  044D
#OUT char
024E  F801
#LDR char to reg (15/17)
024F  044E
#OUT char
0250  F801
#LDR char to reg (16/17)
0251  044F
#OUT char
0252  F801
#LDR char to reg (17/17)
0253  0450
#OUT char
0254  F801
# SCRL
#0255  F000
#LDX
#0256  A443
#LDX
#0257  
#At the very end, jump back to the central program.
#0258
### The text of first message
#E
0400  0045
#N
0401  004E
#T
0402  0054
#E
0403  0045
#R
0404  0052
# 
0405  0020
#2
0406  0032
#0
0407  0030
# 
0408  0020
#I
0409  0049
#N
040A  004E
#T
040B  0054
#E
040C  0045
#G
040D  0047
#E
040E  0045
#R
040F  0052
#S
0410  0053
### The text of second message
#E
0411  0045
#N
0412  004E
#T
0413  0054
#E
0414  0045
#R
0415  0052
# 
0416  0020
#O
0417  004F
#N
0418  004E
#E
0419  0045
# 
041A  0020
#I
041B  0049
#N
041C  004E
#T
041D  0054
#E
041E  0045
#G
041F  0047
#E
0420  0045
#R
0421  0052
#####################
##################### - JAE'S CODE BELOW HERE
#####################
#
## Clear all the GPR's (CLR)
0500  0403
0501  0503
0502  0603
0503  0703
## Clear all the IXR's (CLX)
0504  A443
0505  A483
0506  A4C3
#####
##### 1. Store the address of the first integer digit to currentIntegerPointer - DONE.
#####
# 1) Load IXR1 with the address of the first integer digit (Address: 0015 => Content: 0040) (LDX) 
0507  A455
# 2) Load GPR0 with IXR1 = the address of the first integer digit (0040) (LDA)
0508  0C40
# 3) Load IXR2 with the content of 001B = the address of currentIntegerPointer (Address: 001B => Content: 00BD) (LDX)
0509  A49B
# 4) Store GPR0 to memory[content of IXR2] => currentIntegerPointer holds the address of the first integer digit (STR)
050A  0880
#####
##### 2. Load the first digit of the first integer into a register - DONE.
#####
# 1) Load IXR1 with the address of the first integer digit (Address: 0015 => Content: 0040) (LDX)
050B  A455
# 2) Load GPR0 with memory[content of IXR1] = the first integer digit (LDR)
050C  0440
#####
##### 3. Load the first digit of the user value into a register - DONE.
#####
# 1) Load IXR2 with the address of the first user input digit (Address: 0016 => Content: 00A4) (LDX)
050D  A496
# 2) Load GPR1 with memory[content of IXR2] = the first user value digit (LDR)
050E  0580
#####
##### 4. Compare each digits of integer and user value - DONE.
#####
# 1) Compare GPR0 and GPR1 (TRR)
050F  5840
# 2) Load IXR3 with the address of incrementing digit location (Address: 001D => Content: 0600) (LDX)
0510  A4DD
# 3) Jump to incrementing digit part if digits match (cc == 1) (JCC)
0511  30C0
#
#####
#####
##### 5. If digits don't match (cc == 0), compare integer to user value and store the difference in "difference"
#####
#####
0512
#
#####
#####
##### 6. Compare digitPosition and bestDigitPosition - DONE.
#####
#####
# 1) Load IXR1 with the address of bestDigitPosition (Address: 0019 => Content: 00BB) (LDX)
0520  A459
# 2) Load IXR2 with the address of digitPosition (Address: 0018 => Content: 00BA) (LDX)
0521  A498
# 3) Load bestDigitPosition to GPR0 (LDR)
0522  0440
# 4) Load digitPosition to GPR1 (LDR)
0523  0580
# 5) Check if digitPosition > bestDigitPosition (TIR)
0524  6840
# 6) Load IXR3 with the address of "DIGIT POSITION > BEST DIGIT POSITION CASE" location (Address: 001E => Content: 0800) (LDX)
0525  A4DE
# 7) Jump to "DIGIT POSITION > BEST DIGIT POSITION CASE" location if cc == 1 (JCC)
0526  30C0
# 8) Check if digitPosition == bestDigitPosition (TRR)
0527  5840
# 9) Load IXR3 with the address of "DIGIT POSITION == BEST DIGIT POSITION CASE" location (Address: 001F => Content: 0900) (LDX)
0528  A4DF
# 10) Jump to "DIGIT POSITION == BEST DIGIT POSITION" location 
0529  30C0
#####
#####
##### DIGIT POSITION > BEST DIGIT POSITION CASE
#####
#####
#0800
#####
#####
##### DIGIT POSITION == BEST DIGIT POSITION CASE
#####
#####
#0900
##### DIGITS MATCHING CASE
##### 
##### Increment digit position by 1
#####
# 1) Load IXR1 with the address of digitPosition (Address: 0018 => Content: 00BA)
0600  A458
# 2) Load GPR1 with memory[content of IXR1] = digitPosition (LDR)
0601  0540
# 3) Add 1 to GPR1 (GPR1 = digitPosition) (AIR)
0602  1901
# 4) Update digitPosition on memory (STR)
0603  0940
#####
##### JUMP BACK TO DIGIT COMPARISON
#####
##### Replace the integer with the next digit value
##### UNDONE BELOW HERE
# 1) Load IXR1 with the content of 001B = address of currentIntegerPointer (Address: 001B => Content: 00BD) (LDX)
0603  A45B
# 2) Load GPR0 with the content of IXR1 = currentIntegerPointer value = first integer digit address (LDA)
0604  0C40
# 3) Add GPR0 with GPR1 and update GPR0 with the result
0605  2040
# 4) Store 
#####
##### Replace the user value with the next digit value
#####
# 1) Load GPR0 with the content of 0016 = address of user value (Address: 0016 => Content: 00A4) (LDA)
0606  0C16
# 2) Add GPR0 with GPR1 and update GPR0 with the result
0607  2040
# bestIntegerPointer = currentIntegerPointer
# bestDifference = difference
# bestDigitPosition = digitPosition
# Load GPR1 with the 
0530
# Check if digitPosition == bestDigitPosition (TRR)
0511  5840
# bestIntegerPointer = currentIntegerPointer
# bestDifference = difference
#####
##### 
##### 7. Reset digitPosition and Difference to 0 - DONE
#####
#####
# 1) Load IXR1 with the address of digitPosition (Address: 0018 => Content: 00BA) (LDX)
0700  A458
# 2) Load IXR2 with the address of Difference (Address: 0017 => Content: 00B0) (LDX)
0701  A497
# 3) Clear GPR0 => set to 0 (LDR)
0702  0403
# 4) Set digitPosition to 0 (STR)
0703  0840
# 5) Set difference to 0 (STR)
0704  0880
#####
#####
##### 8. Increment intListNumber by 1 - DONE
#####
#####
# 1) Load IXR1 with the address of intListNumber (Address: 001C => Content: 00BE) (LDX)
0705  A45C
# 2) Load GPR0 with memory[content of IXR1]= intListNumber (LDR)
0706  0440
# 3) Add 1 to GPR0 (GPR0 = intListNumber) (AIR)
0707  1801
# 4) Update intListNumber on memory (STR)
0708  0840
#####
#####
##### 9. CHECK IF INT LIST NUMBER HAS REACHED THE END - ALMOST DONE 
#####  
#####
# 1) Load IXR1 with the address of intListNumber (Address: 001C => Content: 00BE) (LDX)
0709  A45C
# 2) Load GPR0 with memory[content of IXR1]= intListNumber (LDR)
070A  0440
# 3) Set GPR1 to 0 (LDR)
070B  0503
# 4) Add 20 to GPR1 (AIR)
070C  1914
# 5) Check if GPR0 > GPR1 (TIR)
070D  6900
# 6) Load IXR1 with the ending subroutine address (LDX) => gotta know the address
070E
# 7) If GPR0 > GPR1 (cc == 1), jump to the ending subroutine address (JCC)
070F  3040
# 8) Load IXR1 with the comparison address (LDX) => gotta know the address
0710
# 9) If not, jump back to comparison address (JMA)
0711  3440
